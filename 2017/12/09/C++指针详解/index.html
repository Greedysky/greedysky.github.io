<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++ 指针详解 | Greedysky&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 指针详解">
<meta property="og:url" content="http://greedysky.github.io/2017/12/09/C++指针详解/index.html">
<meta property="og:site_name" content="Greedysky's Blog">
<meta property="og:description" content="指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。">
<meta property="og:updated_time" content="2022-11-25T16:04:37.270Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 指针详解">
<meta name="twitter:description" content="指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。">
  
    <link rel="alternative" href="/atom.xml" title="Greedysky&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">Greedysky</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Where there is a will, there is a way.</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">个人首页</a></li>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/ttk">天天酷音</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=laahoa2npqWhpdXk5Lv2_vg" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/Greedysky" title="github">github</a>
                            
                                <a class="fl weibo" target="_blank" href="http://weibo.com/3846499529" title="weibo">weibo</a>
                            
                                <a class="fl google" target="_blank" href="#" title="google">google</a>
                            
                                <a class="fl rss" target="_blank" href="#" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/C-11/" style="font-size: 16.67px;">C++11</a> <a href="/tags/C-17/" style="font-size: 13.33px;">C++17</a> <a href="/tags/C-20/" style="font-size: 13.33px;">C++20</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://download.csdn.net/album/detail/3094">天天酷音</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://download.csdn.net/album/detail/3219">编程思想</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://download.csdn.net/album/detail/3221">C++编程</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://download.csdn.net/album/detail/3222">Qt编程</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://qt-project.org/">Qt</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.qtcn.org/">QtCN</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">世界那么大，我想出去走走！</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Greedysky</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Greedysky</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Where there is a will, there is a way.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">个人首页</a></li>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/ttk">天天酷音</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=laahoa2npqWhpdXk5Lv2_vg" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/Greedysky" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="http://weibo.com/3846499529" title="weibo">weibo</a>
                    
                        <a class="google" target="_blank" href="#" title="google">google</a>
                    
                        <a class="rss" target="_blank" href="#" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-C++指针详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/09/C++指针详解/" class="article-date">
      <time datetime="2017-12-09T10:20:45.000Z" itemprop="datePublished">2017-12-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ 指针详解
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术专帖/">技术专帖</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a><strong>指针的概念</strong></h2><p>&#160; &#160; &#160; &#160;指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。<br>&#160; &#160; &#160; &#160;先声明几个指针放着做例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptr;  </div><div class="line"><span class="keyword">char</span> *ptr;  </div><div class="line"><span class="keyword">int</span> **ptr;  </div><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>];  </div><div class="line"><span class="keyword">int</span> *(*ptr)[<span class="number">4</span>];</div></pre></td></tr></table></figure></p>
<h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a><strong>指针的类型</strong></h2><p>&#160; &#160; &#160; &#160;从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指针的类型是int *  </span></div><div class="line"><span class="keyword">char</span> *ptr; <span class="comment">//指针的类型是char *  </span></div><div class="line"><span class="keyword">int</span> **ptr; <span class="comment">//指针的类型是 int **  </span></div><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针的类型是 int(*)[3]  </span></div><div class="line"><span class="keyword">int</span> *(*ptr)[<span class="number">4</span>]; <span class="comment">//指针的类型是 int *(*)[4]</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;怎么样？找出指针的类型的方法是不是很简单？</p>
<h2 id="指针所指向的类型"><a href="#指针所指向的类型" class="headerlink" title="指针所指向的类型"></a><strong>指针所指向的类型</strong></h2><p>&#160; &#160; &#160; &#160;当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。<br>&#160; &#160; &#160; &#160;从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指针所指向的类型是int  </span></div><div class="line"><span class="keyword">char</span> *ptr; <span class="comment">//指针所指向的的类型是char  </span></div><div class="line"><span class="keyword">int</span> **ptr; <span class="comment">//指针所指向的的类型是 int *  </span></div><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针所指向的的类型是 int()[3]  </span></div><div class="line"><span class="keyword">int</span> *(*ptr)[<span class="number">4</span>]; <span class="comment">//指针所指向的的类型是 int *()[4]</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在指针的算术运算中，指针所指向的类型有很大的作用。<br>&#160; &#160; &#160; &#160;指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。</p>
<h2 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a><strong>指针的值</strong></h2><p>&#160; &#160; &#160; &#160;指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。<br>&#160; &#160; &#160; &#160;指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。<br>&#160; &#160; &#160; &#160;指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。<br>&#160; &#160; &#160; &#160;以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？</p>
<h2 id="指针本身所占据的内存区"><a href="#指针本身所占据的内存区" class="headerlink" title="指针本身所占据的内存区"></a><strong>指针本身所占据的内存区</strong></h2><p>&#160; &#160; &#160; &#160;指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。<br>&#160; &#160; &#160; &#160;指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。</p>
<h2 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a><strong>指针的算术运算</strong></h2><p>&#160; &#160; &#160; &#160;指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[<span class="number">20</span>];   </div><div class="line"><span class="keyword">int</span> *ptr=a;  </div><div class="line">...  </div><div class="line">...   ptr++;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。<br>&#160; &#160; &#160; &#160;由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。<br>&#160; &#160; &#160; &#160;我们可以用一个指针和一个循环来遍历一个数组，看例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>];  </div><div class="line"><span class="keyword">int</span> *ptr=<span class="built_in">array</span>;  </div><div class="line">...  </div><div class="line"><span class="comment">//此处略去为整型数组赋值的代码。  </span></div><div class="line">...  </div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)  </div><div class="line">&#123;      (*ptr)++;      ptr++；  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。再看例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[<span class="number">20</span>];  </div><div class="line"><span class="keyword">int</span> *ptr = a;  </div><div class="line">...  </div><div class="line">...  </div><div class="line">ptr += <span class="number">5</span>;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。<br>&#160; &#160; &#160; &#160;如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方向移动了20个字节。<br>&#160; &#160; &#160; &#160;总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区，将比ptrold所指向的内存区，向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值，减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区，将比ptrold所指向的内存区，向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。</p>
<h2 id="运算符-amp-和"><a href="#运算符-amp-和" class="headerlink" title="运算符&amp;和*"></a><strong>运算符&amp;和*</strong></h2><p>&#160; &#160; &#160; &#160;这里&amp;是取地址运算符，<em>是…书上叫做“间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个</em>，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。<em>p的运算结果就五花八门了。总之</em>p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。</p>
<h2 id="指针表达式"><a href="#指针表达式" class="headerlink" title="指针表达式"></a><strong>指针表达式</strong></h2><p>&#160; &#160; &#160; &#160;一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a,b;  </div><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];  </div><div class="line"><span class="keyword">int</span> *pa;  </div><div class="line">pa=&amp;a;<span class="comment">//&amp;a是一个指针表达式。  </span></div><div class="line"><span class="keyword">int</span> **ptr=&amp;pa;<span class="comment">//&amp;pa也是一个指针表达式。  </span></div><div class="line">*ptr=&amp;b;<span class="comment">//*ptr和&amp;b都是指针表达式。  </span></div><div class="line">pa=<span class="built_in">array</span>;  </div><div class="line">pa++;<span class="comment">//这也是指针表达式。</span></div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *arr[<span class="number">20</span>];  </div><div class="line"><span class="keyword">char</span> **parr=arr;<span class="comment">//如果把arr看作指针的话，arr也是指针表达式  </span></div><div class="line"><span class="keyword">char</span> *str;  </div><div class="line">str=*parr;<span class="comment">//*parr是指针表达式  </span></div><div class="line">str=*(parr+<span class="number">1</span>);<span class="comment">//*(parr+1)是指针表达式  </span></div><div class="line">str=*(parr+<span class="number">2</span>);<span class="comment">//*(parr+2)是指针表达式</span></div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。<br>&#160; &#160; &#160; &#160;好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。 在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。<em>ptr是一个左值，因为</em>ptr这个指针已经占据了内存，其实<em>ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么</em>ptr当然也有了自己的位置。</p>
<h2 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a><strong>数组和指针的关系</strong></h2><p>&#160; &#160; &#160; &#160;如果对声明数组的语句不太明白的话，请参阅我前段时间贴出的文章&lt;&lt;如何理解c和c++的复杂类型声明&gt;&gt;。 数组的数组名其实可以看作一个指针。看下例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,value;  </div><div class="line">...  </div><div class="line">...  </div><div class="line">value=<span class="built_in">array</span>[<span class="number">0</span>];<span class="comment">//也可写成：value=*array;  </span></div><div class="line">value=<span class="built_in">array</span>[<span class="number">3</span>];<span class="comment">//也可写成：value=*(array+3);  </span></div><div class="line">value=<span class="built_in">array</span>[<span class="number">4</span>];<span class="comment">//也可写成：value=*(array+4);</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int <em>，所指向的类型是数组单元的类型即int。因此</em>array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *str[<span class="number">3</span>]=&#123;  </div><div class="line"><span class="string">"Hello,this is a sample!"</span>,  </div><div class="line"><span class="string">"Hi,good morning."</span>,  </div><div class="line"><span class="string">"Hello world"</span>  </div><div class="line">&#125;;  </div><div class="line"><span class="keyword">char</span> s[<span class="number">80</span>]；  </div><div class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">0</span>]);<span class="comment">//也可写成strcpy(s,*str);  </span></div><div class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">1</span>]);<span class="comment">//也可写成strcpy(s,*(str+1));  </span></div><div class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">2</span>]);<span class="comment">//也可写成strcpy(s,*(str+2));</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char<em>，它指向的类型是char 。<br>&#160; &#160; &#160; &#160;</em>str也是一个指针，它的类型是char<em>，它所指向的类型是char，它指向的地址是字符串”Hello,this is a sample!”的第一个字符的地址，即’H’的地址。 str+1也是一个指针，它指向数组的第1号单元，它的类型是char</em>，它指向的类型是char 。<br>&#160; &#160; &#160; &#160;<em>(str+1)也是一个指针，它的类型是char</em>，它所指向的类型是char，它指向”Hi,good morning.”的第一个字符’H’，等等。<br>&#160; &#160; &#160; &#160;下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE [n]；第二，它是一个指针，该指针的类型是TYPE<em>，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。<br>&#160; &#160; &#160; &#160;在不同的表达式中数组名array可以扮演不同的角色。<br>&#160; &#160; &#160; &#160;在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。<br>&#160; &#160; &#160; &#160;在表达式</em>array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(<em>array)测出的是数组单元的大小。<br>&#160; &#160; &#160; &#160;表达式array+n（其中n=0，1，2，….。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE</em>，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];  </div><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>];  </div><div class="line">ptr=&amp;<span class="built_in">array</span>;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上例中ptr是一个指针，它的类型是int (*)[10]，他指向的类型是int [10]，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array代表数组本身。<br>&#160; &#160; &#160; &#160;本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢，还是指针所指向的类型的大小？答案是前者。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>];</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;则在32位程序中，有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>(*)[<span class="number">10</span>])==<span class="number">4</span>  </div><div class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span> [<span class="number">10</span>])==<span class="number">40</span>  </div><div class="line"><span class="keyword">sizeof</span>(ptr)==<span class="number">4</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<h2 id="指针和结构类型的关系"><a href="#指针和结构类型的关系" class="headerlink" title="指针和结构类型的关系"></a><strong>指针和结构类型的关系</strong></h2><p>&#160; &#160; &#160; &#160;可以声明一个指向结构类型对象的指针。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> MyStruct  </div><div class="line">&#123;  </div><div class="line"><span class="keyword">int</span> a;  </div><div class="line"><span class="keyword">int</span> b;  </div><div class="line"><span class="keyword">int</span> c;  </div><div class="line">&#125;  </div><div class="line">MyStruct ss=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;<span class="comment">//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。</span></div><div class="line">MyStruct *ptr=&amp;ss;<span class="comment">//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。</span></div><div class="line"><span class="keyword">int</span> *pstr=(<span class="keyword">int</span>*)&amp;ss;<span class="comment">//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;请问怎样通过指针ptr来访问ss的三个成员变量？答案：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;a;  </div><div class="line">ptr-&gt;b;  </div><div class="line">ptr-&gt;c;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;又请问怎样通过指针pstr来访问ss的三个成员变量？答案：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*pstr；<span class="comment">//访问了ss的成员a。  </span></div><div class="line">*(pstr+<span class="number">1</span>);<span class="comment">//访问了ss的成员b。  </span></div><div class="line">*(pstr+<span class="number">2</span>)<span class="comment">//访问了ss的成员c。</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;呵呵，虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>]=&#123;<span class="number">35</span>,<span class="number">56</span>,<span class="number">37</span>&#125;;  </div><div class="line"><span class="keyword">int</span> *pa=<span class="built_in">array</span>;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;通过指针pa访问数组array的三个单元的方法是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*pa;<span class="comment">//访问了第0号单元  </span></div><div class="line">*(pa+<span class="number">1</span>);<span class="comment">//访问了第1号单元  </span></div><div class="line">*(pa+<span class="number">2</span>);<span class="comment">//访问了第2号单元</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。<br>&#160; &#160; &#160; &#160;所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个“填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。<br>&#160; &#160; &#160; &#160;所以，在例十二中，即使pstr访问到了结构对象ss的第一个成员变量a，也不能保证(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。<br>&#160; &#160; &#160; &#160;通过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。</p>
<h2 id="指针和函数的关系"><a href="#指针和函数的关系" class="headerlink" title="指针和函数的关系"></a><strong>指针和函数的关系</strong></h2><p>&#160; &#160; &#160; &#160;可以把一个指针声明成为一个指向函数的指针。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">char</span>*,<span class="keyword">int</span>)</span></span>;  </div><div class="line"><span class="keyword">int</span> (*pfun1)(<span class="keyword">char</span>*,<span class="keyword">int</span>);  </div><div class="line">pfun1=fun1;  </div><div class="line">....  </div><div class="line">....  </div><div class="line"><span class="keyword">int</span> a=(*pfun1)(<span class="string">"abcdefg"</span>,<span class="number">7</span>);<span class="comment">//通过函数指针调用函数。</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/12/09/C++指针详解/">C++ 指针详解</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Greedysky 的个人博客">Greedysky</a></p>
        <p><span>发布时间:</span>2017年12月09日 - 18时20分</p>
        <p><span>最后更新:</span>2022年11月26日 - 00时04分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/12/09/C++指针详解/" title="C++ 指针详解">http://greedysky.github.io/2017/12/09/C++指针详解/</a>
            <span class="copy-path" data-clipboard-text="原文: http://greedysky.github.io/2017/12/09/C++指针详解/　　作者: Greedysky" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2018/01/22/C++对象数组与对象指针/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          C++ 对象数组与对象指针
        
      </div>
    </a>
  
  
    <a href="/2017/11/12/C++NULL和0/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">C++ NULL，0，&#39;\0&#39;，&quot;0&quot;，&quot;\0&quot;</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#指针的概念"><span class="toc-number">1.</span> <span class="toc-text">指针的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针的类型"><span class="toc-number">2.</span> <span class="toc-text">指针的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针所指向的类型"><span class="toc-number">3.</span> <span class="toc-text">指针所指向的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针的值"><span class="toc-number">4.</span> <span class="toc-text">指针的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针本身所占据的内存区"><span class="toc-number">5.</span> <span class="toc-text">指针本身所占据的内存区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针的算术运算"><span class="toc-number">6.</span> <span class="toc-text">指针的算术运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符-amp-和"><span class="toc-number">7.</span> <span class="toc-text">运算符&和*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针表达式"><span class="toc-number">8.</span> <span class="toc-text">指针表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组和指针的关系"><span class="toc-number">9.</span> <span class="toc-text">数组和指针的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针和结构类型的关系"><span class="toc-number">10.</span> <span class="toc-text">指针和结构类型的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针和函数的关系"><span class="toc-number">11.</span> <span class="toc-text">指针和函数的关系</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/require.js/2.1.6/require.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>







    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/01/22/C++对象数组与对象指针/" title="上一篇: C++ 对象数组与对象指针">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2017/11/12/C++NULL和0/" title="下一篇: C++ NULL，0，&#39;\0&#39;，&quot;0&quot;，&quot;\0&quot;">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/11/25/C++模板之SFINAE和enable_if分析/">C++ 模板之SFINAE和enable_if分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/27/C++STL萃取机制/">C++ STL萃取机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/27/C++高阶操作之模板元编程/">C++ 高阶操作：模板元编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/17/C++模板特化与偏特化/">C++ 模板特化与偏特化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/02/C++type-traits分析/">C++ type traits分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/23/C++20协程初探/">C++20 协程初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/05/18/C++20标准正式发布/">C++20 标准正式发布</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/01/C++17折叠表达式/">C++17 折叠表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/05/C++线程安全的单例模式/">C++ 线程安全的单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/10/C++volatile详解/">C++ volatile详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/04/C++assert函数用法总结与注意事项/">C++ assert 函数用法总结与注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/29/C++优先队列priority_queue/">C++ 优先队列priority_queue</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/21/C++多线程的互斥锁应用RAII机制/">C++ 多线程的互斥锁应用RAII机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/12/C++6种内存顺序/">C++ 6 种内存顺序</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/03/C++11中的Lambda函数/">C++11 中的 Lambda 函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/13/C++11右值引用与完美转发/">C++11 右值引用与完美转发</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/08/C++虚函数表及多态内部原理详解/">C++ 虚函数表及多态内部原理详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/C++仿函数了解一下/">C++ 仿函数了解一下</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/20/C++字符编码的转换/">C++ 字符编码的转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/C++11中智能指针的原理详解/">C++11 中智能指针的原理、使用、实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/20/C++20最新进展/">C++20 最新进展：加入模块化和协程，进入特性冻结阶段</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/08/C++建议用nullptr而不是NULL/">C++ 建议用 nullptr 而不是 NULL</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/08/C++一句话帮你理解typedef的用法/">C++ 一句话帮你理解 typedef 的用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/12/C++中是如何调用C接口/">C++ 中是如何调用 C 接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/12/C++shared_ptr从原理来看看栈溢出的危害/">C++ shared_ptr 从原理来看看栈溢出的危害</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/15/C++11中的左值右值和将亡值/">C++11 中的左值、右值和将亡值</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/C++函数指针与指针函数/">C++ 函数指针与指针函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/28/C++string类详解/">C++ string 类详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/30/C++17中那些值得关注的特性/">C++17 中那些值得关注的特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/C++17新特性Top19/">你需要了解的 C++ 17 Top 19 新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/19/C++vector使用注意事项/">C++ vector使用注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/C++类的默认函数/">C++ 类的默认函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/C++const的使用/">C++ const的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/22/C++对象数组与对象指针/">C++ 对象数组与对象指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/C++指针详解/">C++ 指针详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/12/C++NULL和0/">C++ NULL，0，'\0'，"0"，"\0"</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/字符串匹配的Boyer-Moore算法/">字符串匹配的Boyer-Moore算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/10/C++11新特性之thread/">C++11 新特性之thread</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/05/C++11新特性之constexpr关键字/">C++11 新特性之constexpr关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/23/C++11新特性之列表初始化/">C++11 新特性之列表初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/C++11新特性之基于范围的for循环/">C++11 新特性之基于范围的for循环</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/05/C++11新特性之条件变量/">C++11 新特性之条件变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/30/C++11新特性之锁/">C++11 新特性之锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/20/C++11新特性之强制类型转换/">C++11 新特性之强制类型转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/11/C++11新特性之枚举/">C++11 新特性之枚举</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/31/C++11新特性之auto关键字/">C++11 新特性之auto关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/C++11新特性之正则表达式/">C++11 新特性之正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/13/C++11新特性之template/">C++11 新特性之template</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/30/C++11新特性之右值引用与移动/">C++11 新特性之右值引用与移动</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/C++11新特性之随机数库/">C++11 新特性之随机数库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/C++11新特性之Class/">C++11 新特性之Class</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/29/C++11新特性之智能指针/">C++11 新特性之智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/21/C++11新特性之容器相关特性/">C++11 新特性之容器相关特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/06/C++11新特性之lambda/">C++11 新特性之lambda</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/30/C++11新特性之类型推断与类型获取/">C++11 新特性之类型推断与类型获取</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/02/C++11新特性之新类型与初始化/">C++11 新特性之新类型与初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/12/C++虚函数占用大小/">C++ 虚函数占用大小</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/05/Markdown/">Markdown使用指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/08/C++explicit关键字/">C++ explicit关键字</a></li></ul>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/require.js/2.1.6/require.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 Greedysky
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme by Greedysky
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/require.js/2.1.6/require.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>



  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>